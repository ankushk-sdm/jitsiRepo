import React from 'react';
import PropTypes from 'prop-types';
import UIAnalyticsEvent from './UIAnalyticsEvent';
/**
 * This component is used to grab the analytics functions off context.
 * It uses legacy context, but provides an API similar to 16.3 context.
 * This makes it easier to use with the forward ref API.
 */
class AnalyticsContextConsumer extends React.Component {
    constructor(props) {
        super(props);
        /**
         * Store references to the original and patched event props so we can
         * determine when to update the patched props
         */
        this.originalEventProps = {};
        this.patchedEventProps = {};
        // Update patched event props only if the original props have changed
        this.updatePatchedEventProps = (props) => {
            const changedPropCallbacks = Object.keys(this.props.createEventMap).filter(p => this.originalEventProps[p] !== props[p]);
            if (changedPropCallbacks.length > 0) {
                this.patchedEventProps = {
                    ...this.patchedEventProps,
                    ...this.mapCreateEventsToProps(changedPropCallbacks, props),
                };
                changedPropCallbacks.forEach(p => {
                    this.originalEventProps[p] = props[p];
                });
            }
            return this.patchedEventProps;
        };
        this.mapCreateEventsToProps = (changedPropNames, props) => changedPropNames.reduce((modified, propCallbackName) => {
            const eventCreator = this.props.createEventMap[propCallbackName];
            const providedCallback = props[propCallbackName];
            if (!['object', 'function'].includes(typeof eventCreator)) {
                return modified;
            }
            const modifiedCallback = (...args) => {
                const analyticsEvent = typeof eventCreator === 'function'
                    ? eventCreator(this.createAnalyticsEvent, props)
                    : this.createAnalyticsEvent(eventCreator);
                if (providedCallback) {
                    providedCallback(...args, analyticsEvent);
                }
            };
            return {
                ...modified,
                [propCallbackName]: modifiedCallback,
            };
        }, {});
        this.createAnalyticsEvent = (payload) => {
            const { getAtlaskitAnalyticsEventHandlers, getAtlaskitAnalyticsContext, } = this.context;
            return new UIAnalyticsEvent({
                context: (typeof getAtlaskitAnalyticsContext === 'function' &&
                    getAtlaskitAnalyticsContext()) ||
                    [],
                handlers: (typeof getAtlaskitAnalyticsEventHandlers === 'function' &&
                    getAtlaskitAnalyticsEventHandlers()) ||
                    [],
                payload,
            });
        };
        Object.keys(this.props.createEventMap).forEach(p => {
            this.originalEventProps[p] = props.wrappedComponentProps[p];
        });
        this.patchedEventProps = this.mapCreateEventsToProps(Object.keys(this.props.createEventMap), props.wrappedComponentProps);
    }
    render() {
        const patchedEventProps = this.updatePatchedEventProps(this.props.wrappedComponentProps);
        return this.props.children({
            createAnalyticsEvent: this.createAnalyticsEvent,
            patchedEventProps,
        });
    }
}
AnalyticsContextConsumer.contextTypes = {
    getAtlaskitAnalyticsEventHandlers: PropTypes.func,
    getAtlaskitAnalyticsContext: PropTypes.func,
};
AnalyticsContextConsumer.defaultProps = {
    createEventMap: {},
};
export default AnalyticsContextConsumer;
//# sourceMappingURL=AnalyticsContextConsumer.js.map